#include <ctype.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define runtime_assert(condition)                                              \
    if (!(condition)) {                                                        \
        fprintf(stderr,                                                        \
                "%s:%d Runtime assertion failed: " #condition "\n",            \
                __FILE__,                                                      \
                __LINE__);                                                     \
        abort();                                                               \
    }

typedef struct {
    void* samples;
    size_t length;
    uint8_t sample_width;
    uint8_t storage_width;
} sample_table_t;

uint32_t
sample_table_get(const sample_table_t* table, size_t index)
{
    switch (table->storage_width) {
        case 8:
            return ((uint8_t*)table->samples)[index];
        case 16:
            return ((uint16_t*)table->samples)[index];
        case 32:
            return ((uint32_t*)table->samples)[index];
        default:
            runtime_assert(false && "UNREACHABLE");
    }
}

void
sample_table_set(sample_table_t* table, size_t index, uint32_t value)
{
    switch (table->storage_width) {
        case 8:
            ((uint8_t*)table->samples)[index] = value;
            break;
        case 16:
            ((uint16_t*)table->samples)[index] = value;
            break;
        case 32:
            ((uint32_t*)table->samples)[index] = value;
            break;
        default:
            runtime_assert(false && "UNREACHABLE");
    }
}

bool
generate_samples(sample_table_t* table,
                 double (*waveform)(double),
                 uint32_t len,
                 uint8_t sample_width)
{
    uint8_t storage_width = 0;

    if (sample_width <= 8)
        storage_width = 8;
    else if (sample_width <= 16)
        storage_width = 16;
    else if (sample_width <= 32)
        storage_width = 32;
    else {
        fprintf(stderr,
                "Samples with width > 32 bit are not supported. What do "
                "you need such a big sample for anyways?");
        return false;
    }

    void* samples = malloc((storage_width / 8) * len);
    if (!samples) {
        perror("malloc()");
        return false;
    }

    uint32_t max_value;
    if (sample_width == 32)
        max_value = UINT32_MAX;
    else
        max_value = (1U << sample_width) - 1;

    table->samples = samples;
    table->length = len;
    table->sample_width = sample_width;
    table->storage_width = storage_width;

    for (uint32_t i = 0; i < len; ++i) {
        double x = (double)i * 1 / len;
        runtime_assert(x >= 0 && x <= 1);

        double y = waveform(x);
        runtime_assert(y >= 0 && y <= 1);

        uint32_t sample_value = y * max_value;

        // printf("x: %f, y: %f, sample: %u\n", x, y, sample_value);

        sample_table_set(table, i, sample_value);
    }

    return true;
}

static inline size_t
packed_size(size_t num_samples, uint8_t word_width)
{
    return (num_samples * (size_t)word_width + 7) / 8;
}

void
output_c_header(const char* table_name,
                const sample_table_t* table,
                bool packed)
{
    printf("/*\n"
           " * File auto-generated by fuckass C app, wanabe python script\n"
           " * Do whatever the fuck you want with it, idgaf\n"
           " */\n\n");

    char upper_name[256];
    for (int i = 0; table_name[i] && i < 255; i++) {
        upper_name[i] = toupper(table_name[i]);
    }
    upper_name[strlen(table_name)] = '\0';

    printf("#ifndef _%s_H\n", upper_name);
    printf("#define _%s_H\n\n", upper_name);

    printf("#include <stddef.h>\n");
    printf("#include <stdint.h>\n\n");

    printf("#define %s_SAMPLE_COUNT %lu\n", upper_name, table->length);
    printf("#define %s_SAMPLE_WIDTH %u\n\n", upper_name, table->sample_width);

    if (packed) {
        const size_t table_size_packed =
          packed_size(table->length, table->sample_width);

        printf("#define %s_PACKED_SIZE %lu\n\n", upper_name, table_size_packed);

        printf("const uint8_t %s_sample_table[%s_PACKED_SIZE] = {\n\t",
               table_name,
               upper_name);

        size_t packed_idx = 0;
        uint64_t acc = 0;
        uint8_t acc_bits = 0;

        uint32_t mask = (table->sample_width == 32)
                          ? 0xFFFFFFFFu
                          : ((1u << table->sample_width) - 1u);

        for (size_t i = 0; i < table->length; ++i) {
            uint32_t v = sample_table_get(table, i) & mask;
            acc = (acc << table->sample_width) | v;
            acc_bits += table->sample_width;

            while (acc_bits >= 8) {
                uint8_t byte = (uint8_t)(acc >> (acc_bits - 8));
                printf("0x%02X, ", byte);
                packed_idx++;
                if (packed_idx % 12 == 0)
                    printf("\n\t");
                acc_bits -= 8;
                acc &= ((1ULL << acc_bits) - 1ULL);
            }
        }

        if (acc_bits > 0) {
            uint8_t byte = (uint8_t)(acc << (8 - acc_bits));
            printf("0x%02X, ", byte);
            packed_idx++;
            if (packed_idx % 12 == 0)
                printf("\n\t");
        }
    }
    else {
        printf("const ");

        switch (table->storage_width) {
            case 8:
                printf("uint8_t");
                break;
            case 16:
                printf("uint16_t");
                break;
            case 32:
                printf("uint32_t");
                break;
            default:
                runtime_assert(false && "UNREACHABLE");
        }

        printf(
          " %s_sample_table[%s_SAMPLE_COUNT] = {\n\t", table_name, upper_name);

        for (size_t i = 0; i < table->length; ++i) {
            printf("%u, ", sample_table_get(table, i));
            if ((i + 1) % 12 == 0)
                printf("\n\t");
        }
    }

    printf("\n};\n\n");

    if (packed) {
        printf("#ifdef _%s_FUNCTIONS\n\n", upper_name);

        printf("static inline uint32_t\n"
               "unpack_sample(const uint8_t* packed,\n"
               "\t\t\t  uint16_t idx)\n"
               "{\n"
               "\tconst uint8_t sample_width = %s_SAMPLE_WIDTH;\n"
               "\tsize_t bit_pos = idx * (size_t)sample_width;\n"
               "\tsize_t byte_pos = bit_pos/8;\n"
               "\tuint8_t bit_offset = bit_pos%%8;\n"
               "\tsize_t bits_needed = bit_offset + sample_width;\n"
               "\tsize_t bytes_needed = (bits_needed + 7) / 8;\n"
               "\n"
               "\tuint64_t acc = 0;\n"
               "\tfor (size_t i = 0; i < bytes_needed; ++i) {\n"
               "\t\tacc = (acc << 8) | packed[byte_pos + i];\n"
               "\t}\n"
               "\tsize_t total_bits = bytes_needed * 8;\n"
               "\tuint32_t shift = (uint32_t)(total_bits - bit_offset - "
               "sample_width);\n"
               "\tuint32_t mask = (sample_width == 32) ? 0xFFFFFFFFu : ((1u << "
               "sample_width) - 1u);\n"
               "\treturn (uint32_t)((acc >> shift) & mask);\n"
               "}\n\n",
               upper_name);

        printf("#endif // _%s_FUNCTIONS\n", upper_name);
    }

    printf("#endif // _%s_H\n", upper_name);
}

double
f(double x)
{
    return x; // f(x) = x
}

int
main(void)
{
    // TODO: accept some kind of lua file, that has to implemet some function
    // f(x)?
    // FIXME: for now, we'll just implemnt the function in C - only the sample
    // generation matters
    // TODO: also accept table length, bit width values and packed flag

    sample_table_t samples = { 0 };
    if (!generate_samples(&samples, f, 64, 7))
        return 1;

    output_c_header("linear", &samples, true);

    return 0;
}

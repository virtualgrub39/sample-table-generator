#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <math.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <lauxlib.h>
#include <lua.h>
#include <lualib.h>

#include "ketopt.h"

#define IMAGE_WIDTH 640
#define IMAGE_HEIGTH 480
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"
#define OLIVEC_IMPLEMENTATION
#include "olive.c"

static lua_State* L = NULL;
static int ref_f = LUA_REFNIL;

#define runtime_assert(condition)                                              \
    if (!(condition)) {                                                        \
        fprintf(stderr,                                                        \
                "%s:%d Runtime assertion failed: " #condition "\n",            \
                __FILE__,                                                      \
                __LINE__);                                                     \
        abort();                                                               \
    }

typedef struct {
    // void* samples;
    long double* samples;
    size_t length;
    uint8_t sample_width;
    uint8_t storage_width;
} sample_table_t;

bool
generate_samples(sample_table_t* table,
                 double (*waveform)(double),
                 uint32_t len,
                 uint8_t sample_width)
{
    uint8_t storage_width = 0;

    if (sample_width <= 8)
        storage_width = 8;
    else if (sample_width <= 16)
        storage_width = 16;
    else if (sample_width <= 32)
        storage_width = 32;
    else {
        fprintf(stderr,
                "Samples with width > 32 bit are not supported. What do "
                "you need such a big sample for anyways?");
        return false;
    }

    long double* samples = malloc(len * sizeof(long double));
    if (!samples) {
        perror("malloc()");
        return false;
    }

    table->samples = samples;
    table->length = len;
    table->sample_width = sample_width;
    table->storage_width = storage_width;

    for (uint32_t i = 0; i < len; ++i) {
        double x = (double)i * 1 / len;
        runtime_assert(x >= 0 && x <= 1);

        double y = waveform(x);
        if (y < 0)
            return false; // lua failure
        runtime_assert(y >= 0 && y <= 1);

        // printf("x: %f, y: %f, sample: %u\n", x, y, sample_value);

        samples[i] = y;
    }

    return true;
}

static inline size_t
packed_size(size_t num_samples, uint8_t word_width)
{
    return (num_samples * (size_t)word_width + 7) / 8;
}

void
output_c_header(const char* table_name,
                const sample_table_t* table,
                bool packed)
{
    printf("/*\n"
           " * File auto-generated by fuckass C app, wanabe python script\n"
           " * Do whatever the fuck you want with it, idgaf\n"
           " */\n\n");

    char upper_name[256];
    for (int i = 0; table_name[i] && i < 255; i++) {
        upper_name[i] = toupper(table_name[i]);
    }
    upper_name[strlen(table_name)] = '\0';

    printf("#ifndef _%s_H\n", upper_name);
    printf("#define _%s_H\n\n", upper_name);

    printf("#include <stddef.h>\n");
    printf("#include <stdint.h>\n\n");

    printf("#define %s_SAMPLE_COUNT %lu\n", upper_name, table->length);
    printf("#define %s_SAMPLE_WIDTH %u\n\n", upper_name, table->sample_width);

    uint32_t max_value;
    if (table->sample_width == 32)
        max_value = UINT32_MAX;
    else
        max_value = (1U << table->sample_width) - 1;

    if (packed) {
        const size_t table_size_packed =
          packed_size(table->length, table->sample_width);

        printf("#define %s_PACKED_SIZE %lu\n\n", upper_name, table_size_packed);

        printf("const uint8_t %s_sample_table[%s_PACKED_SIZE] = {\n\t",
               table_name,
               upper_name);

        size_t packed_idx = 0;
        uint64_t acc = 0;
        uint8_t acc_bits = 0;

        uint32_t mask = (table->sample_width == 32)
                          ? 0xFFFFFFFFu
                          : ((1u << table->sample_width) - 1u);

        for (size_t i = 0; i < table->length; ++i) {
            uint32_t v = (uint32_t)(table->samples[i] * max_value) & mask;
            acc = (acc << table->sample_width) | v;
            acc_bits += table->sample_width;

            while (acc_bits >= 8) {
                uint8_t byte = (uint8_t)(acc >> (acc_bits - 8));
                printf("0x%02X, ", byte);
                packed_idx++;
                if (packed_idx % 12 == 0)
                    printf("\n\t");
                acc_bits -= 8;
                acc &= ((1ULL << acc_bits) - 1ULL);
            }
        }

        if (acc_bits > 0) {
            uint8_t byte = (uint8_t)(acc << (8 - acc_bits));
            printf("0x%02X, ", byte);
            packed_idx++;
            if (packed_idx % 12 == 0)
                printf("\n\t");
        }
    }
    else {
        printf("const ");

        switch (table->storage_width) {
            case 8:
                printf("uint8_t");
                break;
            case 16:
                printf("uint16_t");
                break;
            case 32:
                printf("uint32_t");
                break;
            default:
                runtime_assert(false && "UNREACHABLE");
        }

        printf(
          " %s_sample_table[%s_SAMPLE_COUNT] = {\n\t", table_name, upper_name);

        for (size_t i = 0; i < table->length; ++i) {
            printf("%u, ", (uint32_t)(table->samples[i] * max_value));
            if ((i + 1) % 12 == 0)
                printf("\n\t");
        }
    }

    printf("\n};\n\n");

    if (packed) {
        printf("#ifdef _%s_FUNCTIONS\n\n", upper_name);

        printf("static inline uint32_t\n"
               "unpack_sample(const uint8_t* packed,\n"
               "\t\t\t  uint16_t idx)\n"
               "{\n"
               "\tconst uint8_t sample_width = %s_SAMPLE_WIDTH;\n"
               "\tsize_t bit_pos = idx * (size_t)sample_width;\n"
               "\tsize_t byte_pos = bit_pos/8;\n"
               "\tuint8_t bit_offset = bit_pos%%8;\n"
               "\tsize_t bits_needed = bit_offset + sample_width;\n"
               "\tsize_t bytes_needed = (bits_needed + 7) / 8;\n"
               "\n"
               "\tuint64_t acc = 0;\n"
               "\tfor (size_t i = 0; i < bytes_needed; ++i) {\n"
               "\t\tacc = (acc << 8) | packed[byte_pos + i];\n"
               "\t}\n"
               "\tsize_t total_bits = bytes_needed * 8;\n"
               "\tuint32_t shift = (uint32_t)(total_bits - bit_offset - "
               "sample_width);\n"
               "\tuint32_t mask = (sample_width == 32) ? 0xFFFFFFFFu : ((1u << "
               "sample_width) - 1u);\n"
               "\treturn (uint32_t)((acc >> shift) & mask);\n"
               "}\n\n",
               upper_name);

        printf("#endif // _%s_FUNCTIONS\n", upper_name);
    }

    printf("#endif // _%s_H\n", upper_name);
}

void
output_image(const char* table_name, const sample_table_t* table)
{
    uint32_t pixels[IMAGE_WIDTH * IMAGE_HEIGTH];

    Olivec_Canvas oc =
      olivec_canvas(pixels, IMAGE_WIDTH, IMAGE_HEIGTH, IMAGE_WIDTH);

    olivec_fill(oc, 0x00ffffff);

    struct {
        uint32_t x, y, w, h;
    } coord_rect;

    uint32_t min_dim = (uint32_t)fminl(IMAGE_WIDTH, IMAGE_HEIGTH);

    coord_rect.w = min_dim * 0.8;
    coord_rect.h = min_dim * 0.8;
    coord_rect.x = ((IMAGE_WIDTH / 2) - (coord_rect.w / 2));
    coord_rect.y = ((IMAGE_HEIGTH / 2) - (coord_rect.h / 2));

#define WHITE 0xFFFFFFFFu
#define BLACK 0xFF000000u
#define RED 0xFF0000FFu

    olivec_fill(oc, WHITE);

#define COORD_X(u) ((uint32_t)(coord_rect.x + ((u) * (float)coord_rect.w)))
#define COORD_Y(u)                                                             \
    ((uint32_t)(coord_rect.y + ((1.0f - (u)) * (float)coord_rect.h)))

#define ARROW(x1, y1, x2, y2, color)                                           \
    do {                                                                       \
        int _ax = COORD_X(x1), _ay = COORD_Y(y1);                              \
        int _bx = COORD_X(x2), _by = COORD_Y(y2);                              \
        olivec_line(oc, _ax, _ay, _bx, _by, color);                            \
                                                                               \
        const int _HL = 12, _HW = 6;                                           \
        int _dx = _bx - _ax, _dy = _by - _ay;                                  \
                                                                               \
        int _dir_horiz = (abs(_dx) >= abs(_dy));                               \
        int _p1x, _p1y, _p2x, _p2y;                                            \
                                                                               \
        if (_dir_horiz) {                                                      \
            /* horizontal arrow */                                             \
            if (_dx > 0) { /* → */                                             \
                _p1x = _bx - _HL;                                              \
                _p1y = _by - _HW;                                              \
                _p2x = _bx - _HL;                                              \
                _p2y = _by + _HW;                                              \
            }                                                                  \
            else { /* ← */                                                     \
                _p1x = _bx + _HL;                                              \
                _p1y = _by + _HW;                                              \
                _p2x = _bx + _HL;                                              \
                _p2y = _by - _HW;                                              \
            }                                                                  \
        }                                                                      \
        else {                                                                 \
            /* vertical arrow */                                               \
            if (_dy > 0) { /* ↓ */                                             \
                _p1x = _bx + _HW;                                              \
                _p1y = _by - _HL;                                              \
                _p2x = _bx - _HW;                                              \
                _p2y = _by - _HL;                                              \
            }                                                                  \
            else { /* ↑ */                                                     \
                _p1x = _bx - _HW;                                              \
                _p1y = _by + _HL;                                              \
                _p2x = _bx + _HW;                                              \
                _p2y = _by + _HL;                                              \
            }                                                                  \
        }                                                                      \
                                                                               \
        olivec_triangle(oc, _bx, _by, _p1x, _p1y, _p2x, _p2y, color);          \
    } while (0)

    ARROW(-0.01, -0.01, 1.06, -0.01, BLACK);
    ARROW(-0.01, -0.01, -0.01, 1.06, BLACK);

    for (uint32_t i = 0; i < table->length; ++i) {
        // olivec_rect(oc,
        //     COORD_X((long double)i / table->length),
        //     COORD_Y(table->samples[i]),
        //     2,
        //     table->samples[i] * coord_rect.h,
        //     RED
        // );
        olivec_circle(oc,
                      COORD_X((long double)i / table->length),
                      COORD_Y(table->samples[i]),
                      2,
                      RED);
    }

    char path[PATH_MAX] = { 0 };
    strcat(path, table_name);
    strcat(path, ".bmp");

    if (!stbi_write_bmp(path, IMAGE_WIDTH, IMAGE_HEIGTH, 4, pixels)) {
        fprintf(stderr, "Couldn't save %s\n", path);
    }
}

double
f(double x)
{
    double y = 0.0;

    lua_rawgeti(L, LUA_REGISTRYINDEX, ref_f);
    lua_pushnumber(L, x);

    if (lua_pcall(L, 1, 1, 0) != LUA_OK) {
        fprintf(stderr, "Lua error in f(): %s\n", lua_tostring(L, -1));
        lua_pop(L, 1);
        return -1.0;
    }

    if (!lua_isnumber(L, -1)) {
        fprintf(stderr, "Lua f() didn’t return a number\n");
        lua_pop(L, 1);
        return -1.0;
    }

    y = lua_tonumber(L, -1);
    lua_pop(L, 1);
    return y;
}

static void
usage(const char* prog)
{
    fprintf(
      stderr,
      "Usage: %s [OPTIONS]\n"
      "  -h, --help           Show this help\n"
      "  -p, --packed         Enable packed mode\n"
      "  -n, --name NAME      Set table name (default: \"function\")\n"
      "  -l, --length N       Set table length (default: 256)\n"
      "  -b, --bits N         Set sample width in bits (default: 8)\n"
      "  -f, --lua FILE       Path to lua file (default: ./example.lua)\n",
      prog);
}
enum {
    ko_help = 256,
    ko_packed,
    ko_name,
    ko_length,
    ko_bits,
    ko_file,
};

static const ko_longopt_t longopts[] = {
    { "help", ko_no_argument, ko_help },
    { "packed", ko_no_argument, ko_packed },
    { "name", ko_required_argument, ko_name },
    { "length", ko_required_argument, ko_length },
    { "bits", ko_required_argument, ko_bits },
    { "lua", ko_required_argument, ko_file },
    { NULL, 0, 0 }
};

int
main(int argc, char* argv[])
{
    bool packed = false;
    char* table_name = "function";
    uint32_t table_length = 256;
    uint32_t sample_width = 8;
    char* lua_file = "./example.lua";

    ketopt_t s = KETOPT_INIT;
    int c;
    const char* ostr = "hpn:l:b:f:";

    while ((c = ketopt(&s, argc, argv, true, ostr, longopts)) != -1) {
        switch (c) {
            case 'h':
            case ko_help:
                usage(argv[0]);
                return 0;

            case 'p':
            case ko_packed:
                packed = true;
                break;

            case 'n':
            case ko_name:
                table_name = s.arg;
                break;

            case 'l':
            case ko_length: {
                errno = 0;
                char* end;
                unsigned long v = strtoul(s.arg, &end, 10);
                if (errno || *end != '\0') {
                    fprintf(stderr, "Invalid table length: %s\n", s.arg);
                    usage(argv[0]);
                    return 1;
                }
                table_length = (uint32_t)v;
                break;
            }

            case 'b':
            case ko_bits: {
                errno = 0;
                char* end;
                unsigned long v = strtoul(s.arg, &end, 10);
                if (errno || *end != '\0' || v > 32) {
                    fprintf(stderr, "Invalid sample width: %s\n", s.arg);
                    usage(argv[0]);
                    return 1;
                }
                sample_width = (uint32_t)v;
                break;
            }

            case 'f':
            case ko_file:
                lua_file = s.arg;
                break;

            case '?':
                fprintf(stderr, "Unknown option: %s\n", argv[s.ind]);
                usage(argv[0]);
                return 1;

            case ':':
                fprintf(
                  stderr, "Option requires an argument: %s\n", argv[s.ind]);
                usage(argv[0]);
                return 1;
        }
    }

    for (int i = s.ind; i < argc; i++) {
        fprintf(stderr, "Unexpected argument: %s\n", argv[i]);
        usage(argv[0]);
        return 1;
    }

    L = luaL_newstate();
    if (!L) {
        fprintf(stderr, "Failed to create lua context.\n");
        return 1;
    }

    luaL_openlibs(L);

    if (luaL_loadfile(L, lua_file) || lua_pcall(L, 0, 0, 0)) {
        fprintf(stderr, "Error loading script: %s\n", lua_tostring(L, -1));
        lua_close(L);
        return 1;
    }

    lua_getglobal(L, "f");

    if (!lua_isfunction(L, -1)) {
        fprintf(stderr, "Script must define function f(x)\n");
        return 1;
    }

    ref_f = luaL_ref(L, LUA_REGISTRYINDEX);

    sample_table_t samples = { 0 };
    if (!generate_samples(&samples, f, table_length, sample_width)) {
        lua_close(L);
        return 1;
    }

    // TODO: more formats?
    output_c_header(table_name, &samples, packed);
    output_image(table_name, &samples);

    if (L && ref_f != LUA_REFNIL) {
        luaL_unref(L, LUA_REGISTRYINDEX, ref_f);
        ref_f = LUA_REFNIL;
    }
    if (L) {
        lua_close(L);
        L = NULL;
    }

    return 0;
}

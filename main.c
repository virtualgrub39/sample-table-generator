#include <ctype.h>
#include <errno.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <lauxlib.h>
#include <lua.h>
#include <lualib.h>

#include "ketopt.h"

static lua_State* L = NULL;
static int ref_f = LUA_REFNIL;

#define runtime_assert(condition)                                              \
    if (!(condition)) {                                                        \
        fprintf(stderr,                                                        \
                "%s:%d Runtime assertion failed: " #condition "\n",            \
                __FILE__,                                                      \
                __LINE__);                                                     \
        abort();                                                               \
    }

typedef struct {
    void* samples;
    size_t length;
    uint8_t sample_width;
    uint8_t storage_width;
} sample_table_t;

uint32_t
sample_table_get(const sample_table_t* table, size_t index)
{
    switch (table->storage_width) {
        case 8:
            return ((uint8_t*)table->samples)[index];
        case 16:
            return ((uint16_t*)table->samples)[index];
        case 32:
            return ((uint32_t*)table->samples)[index];
        default:
            runtime_assert(false && "UNREACHABLE");
    }
}

void
sample_table_set(sample_table_t* table, size_t index, uint32_t value)
{
    switch (table->storage_width) {
        case 8:
            ((uint8_t*)table->samples)[index] = value;
            break;
        case 16:
            ((uint16_t*)table->samples)[index] = value;
            break;
        case 32:
            ((uint32_t*)table->samples)[index] = value;
            break;
        default:
            runtime_assert(false && "UNREACHABLE");
    }
}

bool
generate_samples(sample_table_t* table,
                 double (*waveform)(double),
                 uint32_t len,
                 uint8_t sample_width)
{
    uint8_t storage_width = 0;

    if (sample_width <= 8)
        storage_width = 8;
    else if (sample_width <= 16)
        storage_width = 16;
    else if (sample_width <= 32)
        storage_width = 32;
    else {
        fprintf(stderr,
                "Samples with width > 32 bit are not supported. What do "
                "you need such a big sample for anyways?");
        return false;
    }

    void* samples = malloc((storage_width / 8) * len);
    if (!samples) {
        perror("malloc()");
        return false;
    }

    uint32_t max_value;
    if (sample_width == 32)
        max_value = UINT32_MAX;
    else
        max_value = (1U << sample_width) - 1;

    table->samples = samples;
    table->length = len;
    table->sample_width = sample_width;
    table->storage_width = storage_width;

    for (uint32_t i = 0; i < len; ++i) {
        double x = (double)i * 1 / len;
        runtime_assert(x >= 0 && x <= 1);

        double y = waveform(x);
        if (y < 0)
            return false; // lua failure
        runtime_assert(y >= 0 && y <= 1);

        uint32_t sample_value = y * max_value;

        // printf("x: %f, y: %f, sample: %u\n", x, y, sample_value);

        sample_table_set(table, i, sample_value);
    }

    return true;
}

static inline size_t
packed_size(size_t num_samples, uint8_t word_width)
{
    return (num_samples * (size_t)word_width + 7) / 8;
}

void
output_c_header(const char* table_name,
                const sample_table_t* table,
                bool packed)
{
    printf("/*\n"
           " * File auto-generated by fuckass C app, wanabe python script\n"
           " * Do whatever the fuck you want with it, idgaf\n"
           " */\n\n");

    char upper_name[256];
    for (int i = 0; table_name[i] && i < 255; i++) {
        upper_name[i] = toupper(table_name[i]);
    }
    upper_name[strlen(table_name)] = '\0';

    printf("#ifndef _%s_H\n", upper_name);
    printf("#define _%s_H\n\n", upper_name);

    printf("#include <stddef.h>\n");
    printf("#include <stdint.h>\n\n");

    printf("#define %s_SAMPLE_COUNT %lu\n", upper_name, table->length);
    printf("#define %s_SAMPLE_WIDTH %u\n\n", upper_name, table->sample_width);

    if (packed) {
        const size_t table_size_packed =
          packed_size(table->length, table->sample_width);

        printf("#define %s_PACKED_SIZE %lu\n\n", upper_name, table_size_packed);

        printf("const uint8_t %s_sample_table[%s_PACKED_SIZE] = {\n\t",
               table_name,
               upper_name);

        size_t packed_idx = 0;
        uint64_t acc = 0;
        uint8_t acc_bits = 0;

        uint32_t mask = (table->sample_width == 32)
                          ? 0xFFFFFFFFu
                          : ((1u << table->sample_width) - 1u);

        for (size_t i = 0; i < table->length; ++i) {
            uint32_t v = sample_table_get(table, i) & mask;
            acc = (acc << table->sample_width) | v;
            acc_bits += table->sample_width;

            while (acc_bits >= 8) {
                uint8_t byte = (uint8_t)(acc >> (acc_bits - 8));
                printf("0x%02X, ", byte);
                packed_idx++;
                if (packed_idx % 12 == 0)
                    printf("\n\t");
                acc_bits -= 8;
                acc &= ((1ULL << acc_bits) - 1ULL);
            }
        }

        if (acc_bits > 0) {
            uint8_t byte = (uint8_t)(acc << (8 - acc_bits));
            printf("0x%02X, ", byte);
            packed_idx++;
            if (packed_idx % 12 == 0)
                printf("\n\t");
        }
    }
    else {
        printf("const ");

        switch (table->storage_width) {
            case 8:
                printf("uint8_t");
                break;
            case 16:
                printf("uint16_t");
                break;
            case 32:
                printf("uint32_t");
                break;
            default:
                runtime_assert(false && "UNREACHABLE");
        }

        printf(
          " %s_sample_table[%s_SAMPLE_COUNT] = {\n\t", table_name, upper_name);

        for (size_t i = 0; i < table->length; ++i) {
            printf("%u, ", sample_table_get(table, i));
            if ((i + 1) % 12 == 0)
                printf("\n\t");
        }
    }

    printf("\n};\n\n");

    if (packed) {
        printf("#ifdef _%s_FUNCTIONS\n\n", upper_name);

        printf("static inline uint32_t\n"
               "unpack_sample(const uint8_t* packed,\n"
               "\t\t\t  uint16_t idx)\n"
               "{\n"
               "\tconst uint8_t sample_width = %s_SAMPLE_WIDTH;\n"
               "\tsize_t bit_pos = idx * (size_t)sample_width;\n"
               "\tsize_t byte_pos = bit_pos/8;\n"
               "\tuint8_t bit_offset = bit_pos%%8;\n"
               "\tsize_t bits_needed = bit_offset + sample_width;\n"
               "\tsize_t bytes_needed = (bits_needed + 7) / 8;\n"
               "\n"
               "\tuint64_t acc = 0;\n"
               "\tfor (size_t i = 0; i < bytes_needed; ++i) {\n"
               "\t\tacc = (acc << 8) | packed[byte_pos + i];\n"
               "\t}\n"
               "\tsize_t total_bits = bytes_needed * 8;\n"
               "\tuint32_t shift = (uint32_t)(total_bits - bit_offset - "
               "sample_width);\n"
               "\tuint32_t mask = (sample_width == 32) ? 0xFFFFFFFFu : ((1u << "
               "sample_width) - 1u);\n"
               "\treturn (uint32_t)((acc >> shift) & mask);\n"
               "}\n\n",
               upper_name);

        printf("#endif // _%s_FUNCTIONS\n", upper_name);
    }

    printf("#endif // _%s_H\n", upper_name);
}

double
f(double x)
{
    double y = 0.0;

    lua_rawgeti(L, LUA_REGISTRYINDEX, ref_f);
    lua_pushnumber(L, x);

    if (lua_pcall(L, 1, 1, 0) != LUA_OK) {
        fprintf(stderr, "Lua error in f(): %s\n", lua_tostring(L, -1));
        lua_pop(L, 1);
        return -1.0;
    }

    if (!lua_isnumber(L, -1)) {
        fprintf(stderr, "Lua f() didnâ€™t return a number\n");
        lua_pop(L, 1);
        return -1.0;
    }

    y = lua_tonumber(L, -1);
    lua_pop(L, 1);
    return y;
}

void
usage(const char* progname)
{
    printf("%s - sample table generator\n", progname);
    printf("ARGUMENTS:\n");
    printf("\t-h | --help\t- display this message\n");
    printf("\t-p\t\t- turn on table packing\n");
    printf("\t-n [name]\t- specify table name\n");
    printf("\t-l [len]\t- specify table length\n");
    printf("\t-b [n]\t\t- specify sample width (in bits)\n");
    printf("\t-f [path]\t- specify lua function path\n");
}

enum {
    ko_help = 256,
    ko_packed,
    ko_name,
    ko_length,
    ko_bits,
    ko_file,
};

static const ko_longopt_t longopts[] = {
    { "help", ko_no_argument, ko_help },
    { "packed", ko_no_argument, ko_packed },
    { "name", ko_required_argument, ko_name },
    { "length", ko_required_argument, ko_length },
    { "bits", ko_required_argument, ko_bits },
    { "lua", ko_required_argument, ko_file },
    { NULL, 0, 0 }
};

int
main(int argc, char* argv[])
{
    bool packed = false;
    char* table_name = "function";
    uint32_t table_length = 256;
    uint32_t sample_width = 8;
    char* lua_file = "./example.lua";

    ketopt_t s = KETOPT_INIT;
    int c;
    const char* ostr = "hpn:l:b:f:";

    while ((c = ketopt(&s, argc, argv, true, ostr, longopts)) != -1) {
        switch (c) {
            case 'h':
            case ko_help:
                usage(argv[0]);
                return 0;

            case 'p':
            case ko_packed:
                packed = true;
                break;

            case 'n':
            case ko_name:
                table_name = s.arg;
                break;

            case 'l':
            case ko_length: {
                errno = 0;
                char* end;
                unsigned long v = strtoul(s.arg, &end, 10);
                if (errno || *end != '\0') {
                    fprintf(stderr, "Invalid table length: %s\n", s.arg);
                    usage(argv[0]);
                    return 1;
                }
                table_length = (uint32_t)v;
                break;
            }

            case 'b':
            case ko_bits: {
                errno = 0;
                char* end;
                unsigned long v = strtoul(s.arg, &end, 10);
                if (errno || *end != '\0' || v > 32) {
                    fprintf(stderr, "Invalid sample width: %s\n", s.arg);
                    usage(argv[0]);
                    return 1;
                }
                sample_width = (uint32_t)v;
                break;
            }

            case 'f':
            case ko_file:
                lua_file = s.arg;
                break;

            case '?':
                fprintf(stderr, "Unknown option: %s\n", argv[s.ind]);
                usage(argv[0]);
                return 1;

            case ':':
                fprintf(
                  stderr, "Option requires an argument: %s\n", argv[s.ind]);
                usage(argv[0]);
                return 1;
        }
    }

    for (int i = s.ind; i < argc; i++) {
        fprintf(stderr, "Unexpected argument: %s\n", argv[i]);
        usage(argv[0]);
        return 1;
    }

    L = luaL_newstate();
    if (!L) {
        fprintf(stderr, "Failed to create lua context.\n");
        return 1;
    }

    luaL_openlibs(L);

    if (luaL_loadfile(L, lua_file) || lua_pcall(L, 0, 0, 0)) {
        fprintf(stderr, "Error loading script: %s\n", lua_tostring(L, -1));
        lua_close(L);
        return 1;
    }

    lua_getglobal(L, "f");

    if (!lua_isfunction(L, -1)) {
        fprintf(stderr, "Script must define function f(x)\n");
        return 1;
    }

    ref_f = luaL_ref(L, LUA_REGISTRYINDEX);

    sample_table_t samples = { 0 };
    if (!generate_samples(&samples, f, table_length, sample_width)) {
        lua_close(L);
        return 1;
    }

    // TODO: more formats?
    output_c_header(table_name, &samples, packed);

    if (L && ref_f != LUA_REFNIL) {
        luaL_unref(L, LUA_REGISTRYINDEX, ref_f);
        ref_f = LUA_REFNIL;
    }
    if (L) {
        lua_close(L);
        L = NULL;
    }

    return 0;
}
